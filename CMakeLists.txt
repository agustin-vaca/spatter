# 3.18 is specified to include FindCUDAToolkit support updates
CMAKE_MINIMUM_REQUIRED (VERSION 3.18 FATAL_ERROR)
PROJECT (spatter C CXX)

SET (CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Set target project name
set (TRGT spatter)

# Use for debugging. TODO: Set this automatically
IF(CMAKE_BUILD_TYPE STREQUAL "Debug")
    # Use ASAN when debugging
    SET( CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fsanitize=address")
ENDIF(CMAKE_BUILD_TYPE STREQUAL "Debug")

# Set default values
SET (USE_CUDA 0 CACHE BOOL "If set, builds with CUDA support")
SET (USE_OPENCL 0 CACHE BOOL "If set, builds with OpenCL support")
SET (USE_OPENMP 0 CACHE BOOL "If set, builds with OpenMP support")
SET (USE_SERIAL 0 CACHE BOOL "If set, builds with Serial support")
SET (USE_PAPI 0 CACHE BOOL "If set, builds with PAPI support")
SET (USE_MPI 0 CACHE BOOL "If set, builds with MPI support")

ADD_DEFINITIONS (-DSG_DATA_TYPE=double)

# Check for support for at least one backend
IF (NOT (USE_CUDA OR USE_OPENCL OR USE_OPENMP OR USE_SERIAL))
    MESSAGE (
        FATAL_ERROR
            "You must build with support for at least one backend. Pass at least one of -DUSE_CUDA=1 -DUSE_OPENCL=1 -DUSE_SERIAL=1 or -DUSE_OPENMP=1 to cmake."
    )
ENDIF ()

# Enable CUDA language
if ("${BACKEND}" STREQUAL "cuda")
    enable_language(CUDA)
endif ()

# Debug function to check all the variables in the CMakeFile
macro (print_all_variables)
    message (
        STATUS "print_all_variables------------------------------------------{"
    )
    get_cmake_property (_variableNames VARIABLES)
    foreach (_variableName ${_variableNames})
        message (STATUS "${_variableName}=${${_variableName}}")
    endforeach ()
    message (
        STATUS "print_all_variables------------------------------------------}"
    )
ENDMACRO ()



# Check that appropriate compiler versions are used
if (CMAKE_COMPILER_IS_GNUCC AND CMAKE_CXX_COMPILER_VERSION VERSION_LESS 4.9)
        message (FATAL_ERROR "GCC version must be at least 4.9.1 to run the OpenMP 4.0 backend")
endif ()


#Add specific flags for the CodeXL compiler
if ("${CMAKE_C_COMPILER_ID}" STREQUAL "XL")
	set(IBMXL_COMPILE_FLAGS "-qenablevmx -qtune=pwr9")
	set(CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} ${IBMXL_COMPILE_FLAGS}")
    set(CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} -DSPAT_C_NAME=IBM")
endif ()

if ("${CMAKE_C_COMPILER_ID}" STREQUAL "Cray") 
    set (OPTIMIZATIONS "-O3 -h vector3 -h cache3 -h scalar3")
    #set (OPTIMIZATIONS "-G0 -O0")
    #set (ALLWARNINGS "-Wall -Wextra -ansi -pedantic")
    #set (ALLWARNINGS "-h msglevel_2")
    set (CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} ${OPTIMIZATIONS} ${ALLWARNINGS} -hlist=m -hlist=d ")
    set (CMAKE_CXX_FLAGS  "${CMAKE_CXX_FLAGS} ${OPTIMIZATIONS} -hlist=m -D__CRAYC__")
    set (CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} -DSPAT_C_NAME=Cray -D__CRAYC__")
endif ()

if ("${CMAKE_C_COMPILER_ID}" STREQUAL "Intel") 
    set (OpenMP_C_FLAGS "${OpenMP_C_FLAGS} -xHost -qopenmp")
    set (OpenMP_C_FLAGS "${OpenMP_CXX_FLAGS} -xHost -qopenmp")
endif ()

 
if ("${CMAKE_C_COMPILER_ID}" STREQUAL "GNU") 
    set(CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} -DSPAT_C_NAME=GNU -O3 -g")
   #Use sanitize=address for debugging of access issues 
   #set(CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} -fsanitize=address")
endif ()

if ("${CMAKE_C_COMPILER_ID}" STREQUAL "Clang") 
    set(CMAKE_C_FLAGS  "${CMAKE_C_FLAGS} -DSPAT_C_NAME=Clang")
endif ()


#Add configure-specified flags
set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -I${CMAKE_CURRENT_SOURCE_DIR}/src/include -I${CMAKE_CURRENT_SOURCE_DIR}/external/argtable3")
set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -I${CMAKE_CURRENT_SOURCE_DIR}/src/include -I${CMAKE_CURRENT_SOURCE_DIR}/external/argtable3")


#Check if Spatter is compiled on MacOSX. If so, use POSIX_MEMALIGN to allocate memory
if (APPLE)
	add_definitions (-DUSE_POSIX_MEMALIGN)
endif ()

# Enable OpenCL
if ("${BACKEND}" STREQUAL "opencl")
    add_definitions (-DUSE_OPENCL)
    # Point the compiler to the include and library directories
    include_directories ($ENV{OCL_INCL} src/opencl)
    # include_directories(/usr/lib/gcc/x86_64-linux-gnu/5/include/)
    link_directories ($ENV{OCL_LIB})
    # Pull the OpenCL-specific files into the build
    file (GLOB BACKEND_C_FILES_CL src/opencl/*.c)
    file (GLOB BACKEND_H_FILES_CL src/opencl/*.h)

    # Copy over the OpenCL kernels used with the binary
    file (GLOB OCL_KERNELS src/opencl/*.cl)
    file (
        COPY
        ${OCL_KERNELS}
        include/sgtype.h
        DESTINATION
        ${CMAKE_CURRENT_BINARY_DIR}/kernels/
    )

    message ("Using OpenCL backend")

endif ()

# Enable Serial backend
if ("${BACKEND}" STREQUAL "serial")
    add_definitions (-DUSE_SERIAL)
    include_directories (src/serial)
    # Pull the serial files and kernels into the build
    file (GLOB BACKEND_C_FILES_SERIAL src/serial/*.c)
    file (GLOB BACKEND_H_FILES_SERIAL src/serial/*.h)
    message ("Using serial backend")
endif ()

#Enable MPI
if (USE_MPI)
    add_definitions (-DUSE_MPI)
    find_package(MPI REQUIRED)
    message(STATUS "Run: ${MPIEXEC} ${MPIEXEC_NUMPROC_FLAG} ${MPIEXEC_MAX_NUMPROCS} ${MPIEXEC_PREFLAGS} EXECUTABLE ${MPIEXEC_POSTFLAGS} ARGS")
endif()

# Enable OpenMP
if ("${BACKEND}" STREQUAL "openmp")
    find_package (OpenMP REQUIRED)
    if(OpenMP_FOUND)
	# enable pragma regions in the code for OpenMP
        add_definitions (-DUSE_OPENMP)
        add_definitions (-DUSE_OMP_SIMD)
        include_directories (src/openmp)

        # Pull the OpenMP-specific files and kernels into the build
        file (GLOB BACKEND_C_FILES_OMP src/openmp/*.c)
        file (GLOB BACKEND_H_FILES_OMP src/openmp/*.h)
    endif ()
    set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
    set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
    message ("Using OpenMP backend")
endif ()

# Enable CUDA
if ("${BACKEND}" STREQUAL "cuda")
    find_package(CUDAToolkit REQUIRED)
    add_definitions (-DUSE_CUDA)
    include_directories (src/cuda)
    set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -I/usr/local/cuda/include")
    set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -I/usr/local/cuda/include")
    set (
        CMAKE_CUDA_FLAGS
        "${CMAKE_CUDA_FLAGS} -I${CMAKE_CURRENT_SOURCE_DIR}/src/include"
    )
    if ("${BACKEND}" STREQUAL "openmp")
        set (CMAKE_CUDA_FLAGS "${CMAKE_CUDA_FLAGS} -Xcompiler -fopenmp")
    endif ()

    file (GLOB CUDA_CU_FILES src/cuda/*.cu)
    file (GLOB CUDA_C_FILES src/cuda/*.c)
    file (GLOB CUDA_H_FILES src/cuda/*.h)

    #CUDA Toolkit (Runtime)
    add_library(cuda_comp SHARED src/cuda/my_kernel.cu src/cuda/cuda-backend.cu src/cuda/cuda-backend.h src/cuda/cuda_kernels.h)
    set_target_properties(cuda_comp
        PROPERTIES
                CUDA_RUNTIME_LIBRARY Shared
    )
    target_include_directories(cuda_comp PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/src/cuda")

    message ("Using CUDA backend")

endif ()

if (USE_PAPI) 
    set (CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake")
    include_directories (src/papi)
    add_definitions (-DUSE_PAPI)
    #Use the included FindPAPI cmake module
    include (FindPAPI)
    find_package (PAPI REQUIRED)
    #message("Found PAPI libraries at ${PAPI_INCLUDE_DIRS}")
    include_directories(${PAPI_INCLUDE_DIRS})
    file (GLOB PAPI_C_FILES src/papi/*.c)
    file (GLOB PAPI_H_FILES src/papi/*.h)
endif ()

# Include the location of stddef.h include_directories(/usr/include/linux/)

# Include amalgamated argtable files
file (GLOB EXTERNAL_C_FILES external/argtable3/*.c)
file (GLOB EXTERNAL_H_FILES external/argtable3/*.h)

# Glob for the source files and headers in the current directory and kernels
file (GLOB C_FILES src/*.c)
file (GLOB H_FILES src/include/*.h)
set (
    SOURCE_FILES
    ${C_FILES}
    ${H_FILES}
    ${EXTERNAL_C_FILES}
    ${EXTERNAL_H_FILES}
    ${BACKEND_C_FILES_CL}
    ${BACKEND_H_FILES_CL}
    ${BACKEND_C_FILES_OMP}
    ${BACKEND_H_FILES_OMP}
    ${BACKEND_C_FILES_SERIAL}
    ${BACKEND_H_FILES_SERIAL}
    ${CUDA_CU_FILES}
    ${CUDA_C_FILES}
    ${PAPI_C_FILES}
    ${PAPI_H_FILES}
)

# Specify the executable and source files
add_executable (${TRGT} ${SOURCE_FILES})

#Prefer C11 standard to allow for loop initialization and aligned_alloc
target_compile_features(${TRGT} PUBLIC c_std_11)

# Print out debug info print_all_variables()

# Link with the appropriate libraries
if ("${BACKEND}" STREQUAL "openmp")
    target_link_libraries (${TRGT} LINK_PUBLIC OpenMP::OpenMP_CXX)
endif()

if ("${BACKEND}" STREQUAL "opencl")
    target_link_libraries (${TRGT} LINK_PUBLIC OpenCL)
endif ()

# Link math library for json
target_link_libraries (${TRGT} LINK_PUBLIC m)

if ("${BACKEND}" STREQUAL "cuda")
    target_link_libraries (${TRGT} PUBLIC cuda_comp)
    target_link_libraries (${TRGT} PUBLIC CUDA::cudart)
endif ()

#Include PAPI libraries, if defined
if (USE_PAPI)
    target_link_libraries (${TRGT} LINK_PUBLIC ${PAPI_LIBRARIES})
    # Explicitly link libdl because the Cray compiler refuses to link papi dynaimically...
    # (Static libraries carry no dependency info, and libpapi depends on libdl)
    target_link_libraries (${TRGT} LINK_PUBLIC dl)
endif ()

#Link MPI libraries
if (USE_MPI)
    target_link_libraries(${TRGT} PUBLIC MPI::MPI_CXX)
endif()

# Copy over the test scripts
file (GLOB TEST_SCRIPTS tests/*.sh)
file (COPY ${TEST_SCRIPTS} DESTINATION ${CMAKE_CURRENT_BINARY_DIR})

# Add a command to put some important info in environment variables 
# to be output by spatter
message (STATUS "compiler version is ${CMAKE_C_COMPILER_VERSION}")
message (STATUS "compiler is ${CMAKE_C_COMPILER}")
set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DSPAT_C=\"${CMAKE_C_COMPILER}\"")
set (CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DSPAT_C_VER=\"${CMAKE_C_COMPILER_VERSION}\"")

# Build tests
if ( "${BACKEND}" STREQUAL "openmp" OR "${BACKEND}" STREQUAL "serial" OR "${BACKEND}" STREQUAL "cuda")
    mark_as_advanced( BUILD_TESTS )
    set( BUILD_TESTS true CACHE BOOL "Tests build target available if true" )
    if( BUILD_TESTS )
        enable_testing()
        add_subdirectory( tests )
    endif()
endif()

# Validation flag
set (VALIDATE_DATA 0 CACHE BOOL "Performs additional validation")
if ("${BACKEND}" STREQUAL "openmp" OR "${BACKEND}" STREQUAL "cuda")
    if (VALIDATE_DATA)
        add_definitions(-DVALIDATE)
    endif ()
endif ()


# Note - This file can be reformatted with cmake-format CMakeLists.txt -i
# --command-case=upper --keyword-case=upper --dangle-parens --tab-size=4
# --separate-ctrl-name-with-space --separate-fn-name-with-space If you do NOT
# have cmake-format installed, install it with pip install --user cmake_format
